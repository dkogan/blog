#+TITLE: Dima Kogan
#-DESCRIPTION: Dima's notes
#+DATE: <2014-07-17 Thu 17:43>
#+AUTHOR Dima Kogan

#+STARTUP: logdone
#+STARTUP: overview

#+PLUGIN_QRCODE: nil
#+TEMPLATE_DIR: templates
#+URL: http://notes.secretsauce.net

#+DEFAULT_CATEGORY: Notes
#+FILENAME_SANITIZER: ob-sanitize-string
#+POST_SORTER: ob-sort-posts-by-title
#+OPTIONS: tex:dvipng

* Blog details
** Copyright
  :PROPERTIES:
  :SNIPPET:  t
  :END:

   The text is in the public domain. All code is copyright [[mailto:dima -at- secretsauce -dot- net][Dima Kogan]], licensed
   under the LGPL.

** Navigation
  :PROPERTIES:
  :SNIPPET:  t
  :END:

- [[file:{lisp}(ob:path-to-root){/lisp}/tags][Tags]]
- [[file:{lisp}(ob:path-to-root){/lisp}/archives.html][Archives]]
- [[file:{lisp}(ob:path-to-root){/lisp}/index.xml][RSS]]
- [[https://www.github.com/dkogan][Github]]

* Toplevel page
  :PROPERTIES:
  :PAGE:     index.html
  :TEMPLATE: blog_static_no_title.html
  :END:

This space is meant to contain whatever Dima is thinking about at various times.
The full set of entries is in the [[file:{lisp}(ob:path-to-root){/lisp}/archives.html][Archives]]. Various coding projects/experiments
are in the [[https://www.github.com/dkogan][Github]] repostories. Contact info is at the bottom of the page (in
tiny print).

Most recent post: [[file:{lisp}(ob:link-to-post (car ALL-POSTS)){/lisp}][{lisp}(ob:post-title (car ALL-POSTS)){/lisp}]]

* Notes
** DONE First post                                             :o@blog:emacs:
  CLOSED: [2014-03-17 Mon 03:48]

So it has come to this. I'd like to know what the hell I actually do all day, so
maybe keeping a record will make that more clear. Today, I started a blog! I had
some ideas about the publishing system I wanted going in, and finding that
system was interesting. Requirements:

- Editing in emacs with org-mode
- Publishing with a simple file copy (or git push, etc)
- Static pages; no server work other than sending the files
- No javascript; no client work other than basic rendering
- Premade templates so that things look reasonable out of the box
- Does not require me to actually learn web development

Turns out you can't have everything, but you can get close. In its simplest, org
itself can push HTML without anything else. This is minimally-styled, and not
assembled into pages that talk to each other. The org-mode wiki (worg) has a
list of various publishing systems that use org as a backend:
http://orgmode.org/worg/org-blog-wiki.html. There are several exporters to
common blogging platforms, and a few specially-written things.

In the end, I was looking at two systems: [[http://renard.github.io/o-blog/][*o-blog*]] and [[https://github.com/kelvinh/org-page][*org-page*]]. Both are
/blogging/ systems, so you get RSS, tags, timelines, etc.

*** Advantages of o-blog

- Neither o-blog or org-page are used heavily, but o-blog appears to have more
  users: I could only find one org-page site that wasn't the author's personal
  page
- Org-page feels a bit rougher than o-blog, which has a much nicer-looking
  layout out of the box
- Org-page feels more boilerplaty. Each file needs lots of tags that could
  potentially conflict
- Org-page has some sort of git integration, which maybe is actually a positive,
  but I didn't dig into it. The main publishing function takes some git refs,
  the system expects a particular branching structure, etc. Those are probably
  good, but it should be obvious what the basic export-all-this-stuff command is

*** Advantages of org-page

- Org-page organizes the posts into several files, while o-blog has the whole
  thing in one file. With o-blog this probably will get slow as the posts
  accumulate. The author is currently working on an update that supposedly would
  resolve this
- The major downside of o-blog is that it produces a very heavy,
  javascript-laden site that doesn't work /at all/ with JS turned off.

I was leaning towards o-blog, so I learned some web-development. O-blog uses
LESS instead of CSS, using some runtime javascript to convert the LESS (that the
browser doesn't understand) to CSS (which the browser /does/ understand). So I
exported the LESS to CSS, scrubbed the output to get rid of the shinier bits,
and I have my blog. This look reasonable, but still not ideal. Current issues:

- The new JS-free navigation bars I wrote disappear when the browser window is
  narrower than some threshold. This is almost certainly intentional in the CSS.
  It needs to do something better than simply disappearing. The JS version /did/
  do someting better, and I should try to match that
- O-blog renders equations with MathJax, which uses javascript. Org has the
  capability to generate images for each equation, and output those. I'd like to
  do that, but o-blog can't figure that out. I'll fix it at some point
- Tables look somewhat weird. Pretty sure this is an org feature (not o-blog).
  On opera I see a full grid, except the left bar. On firefox I see the top and
  bottom bars and no others.

There're probably more, and I'll discover them as I go. In the meantime, the
code and content are on Github.
** DONE Using DEMs to get GPX elevation profiles                :hiking:data:
   CLOSED: [2014-03-18 Tue 00:49]

When considering a new hike, I often want to know the elevation profile of the
route. Usually all I have is a 2D elevation track, from [[http://www.openstreetmap.org][OpenStreetMap]] for
instance; clearly this lacks elevation information.

Unrelatedly we have access to gridded elevation data. This primarily comes from
the [[http://en.wikipedia.org/wiki/SRTM][SRTM]] project: data available here: http://dds.cr.usgs.gov/srtm/version2_1/.
The raw SRTM data is pretty good, but there are some gaps. Some people have
cleaned up the raw data, to make clean tiles available. One such data source is
here: http://www.viewfinderpanoramas.org/dem3/.

So we have 2D track data and topography. We can thus combine these into a full
3D track. This isn't perfect since DEM data is granular, but it's way better
than nothing.

I just found out that there's a route to [[http://www.openstreetmap.org/#map=15/34.1662/-117.9293][Fish Canyon Falls]] that goes around the
rock quarry, and thus is open year-round. Bypassing the quarry requires climbing
up a steep hillside to gain a ridge, then descending the other side of the ridge
to the bottom of the canyon behind the quarry. Just how much extra climbing is
involved here? To find out, I wrote this:

#+CAPTION: =gpxSampleDEM.pl=
#+begin_src perl
#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Euclid;
use feature ':5.10';
use autodie;

use Geo::Gpx;
use PDL;


my $W = 1201; # I use 3-minute DEMs, so each DEM is 1201 x 1201

my $gpx_fh;
if( $ARGV{'<input>'} eq '-' )
{
    $gpx_fh = \*STDIN;
}
else
{
  open $gpx_fh, '<', $ARGV{'<input>'};
}

my $gpx = Geo::Gpx->new( input => $gpx_fh );

my $iter = $gpx->iterate_points();
while( my $pt = $iter->() )
{
    say join( ' ', $pt->{lon}, $pt->{lat}, elevation( $pt->{lon}, $pt->{lat} ) );
}



sub elevation
{
    my ($lon, $lat) = @_;

    state %DEMs;
    my $demfileE = floor $lon;
    my $demfileN = floor $lat;

    $DEMs{$demfileE}{$demfileN} //= readDEM($demfileE, $demfileN);
    my $dem = $DEMs{$demfileE}{$demfileN};
    return 0 if( !ref($dem) );

    # use PDL::Graphics::Gnuplot;
    # gplot( with => 'image', $dem );
    # sleep(20);

    # the DEMs start in the NW corner
    my $ilon =      ($lon - $demfileE)  * $W;
    my $ilat = (1 - ($lat - $demfileN)) * $W;

    return 100.0/2.54/12.0 * $dem->interpND( pdl[$ilon, $ilat] );
}

sub readDEM
{
    my ($demfileE, $demfileN) = @_;

    my $path;
    if   ($demfileN >= 0 && $demfileE >= 0){ $path = sprintf("$ARGV{'--demdir'}/N%.2dE%.3d.hgt", $demfileN,  $demfileE); }
    elsif($demfileN >= 0 && $demfileE <  0){ $path = sprintf("$ARGV{'--demdir'}/N%.2dW%.3d.hgt", $demfileN, -$demfileE); }
    elsif($demfileN  < 0 && $demfileE >= 0){ $path = sprintf("$ARGV{'--demdir'}/S%.2dE%.3d.hgt", -$demfileN, $demfileE); }
    else                                   { $path = sprintf("$ARGV{'--demdir'}/S%.2dW%.3d.hgt", -$demfileN, -$demfileE); }

    say STDERR "Reading DEM '$path'";
    if( ! -e $path )
    {
        warn "DEM '$path' not found. All of its elevations will read as 0";
        return 0;
    }

    # I read the DEM on disk into the piddle, then flip the endianness of the
    # data. I wouldn't have to copy anything if the data was little-endian to
    # start with; I'd just mmap into the piddle.
    open my $fd, '<', $path;
    my $dem = zeros(short, $W, $W);
    sysread( $fd, ${$dem->get_dataref}, $W*$W*2, 0 );
    ${$dem->get_dataref} = pack( "s*", unpack("s>*", ${$dem->get_dataref}));

    # I also convert to floating point. Turns out the PDL interpolation routines
    # don't work with integers
    return $dem->float;
}



__END__

=head1 NAME

gpxSampleDEM.pl - Samples SRTM DEM data to compute elevations for a GPX track

=head1 OPTIONAL ARGUMENTS

=over

=item --demdir <demdir>

Directory that contains the DEM files

=for Euclid:
  demdir.type: string, -d demdir && -e demdir
  demdir.default: '.'

=item <input>

GPX input. If omitted or '-', the input is read from standard input

=for Euclid:
  input.type: readable
  input.default: '-'

=back

=head1 AUTHOR

Dima Kogan, C<< <dima@secretsauce.net> >>
#+end_src

The script is fairly straightforward. It examines every track point in the GPX,
finds the appropriate elevation using plain bilinear interpolation, and outputs
a (lon,lat,ele) tuple on STDOUT. On Debian the dependencies are

- =libgetopt-euclid-perl=
- =libgeo-gpx-perl=
- =pdl=

You need to pre-download 3" DEMs, and pass the directory to the script (1" would
certainly work better, but I haven't tried). Given the [[file:files/FishCanyonFalls/FishCanyonFallsTrail.gpx][gpx file]] scraped from an
OpenStreetMap way (itself traced from the satellite imagery), you can do this:

#+begin_src sh
gpxSampleDEM.pl --demdir DEMs FishCanyonFallsTrail.gpx | \
  feedgnuplot --domain --3d --lines --square_xy          \
     --xlabel 'lon(deg)' --ylabel 'lat(deg)' --zlabel 'Elevation(m)'
#+end_src

This makes an interactive 3D plot of the route. For a more traditional elevation
profile that's monotonic in distance, you can do something like this:

#+begin_src sh
gpxSampleDEM.pl --demdir DEMs FishCanyonFallsTrail.gpx | \
  awk '{print $3}'                                     | \
  feedgnuplot --lines                                    \
     --xlabel 'Monotonic with distance' --ylabel 'Elevation(m)'
#+end_src

I actually did go see this waterfall today (which is really nice). Here's a plot
of the elevation profile I gathered with my GPS unit today overlaid over the
elevation profile from the DEM:

#+begin_comment
Following plot made by exporting each data source, and plotting with gnuplot

gpx_xyz.pl ~/hiking/gpx/FishCanyonFalls.gpx | awk '!/#/ {print $3}' > real
gpxSampleDEM.pl --demdir ~/projects/horizon/DEMs_SRTM3.bak/ FishCanyonFallsTrail.gpx | awk '{print $3}' > fake

set xlabel "Monotonic with distance"
set ylabel "Elevation (m)"
set terminal svg
set output "FishCanyonFalls.svg"
plot "real" using ($0/1101):1 with lines title "Actual track from a hike", "fake" using ($0/1400):1 with lines title "Generated from a DEM"
set output
#+end_comment

#+ATTR_HTML: :width 80%
[[file:files/FishCanyonFalls/FishCanyonFalls.svg]]

Immediately several issues are noticeable[fn:1]. First of all, while each curve
is monotonic with distance, the relationship of the domain with distance is
different. This plot assumes they're both /linear/ with distance. It's not
really true, but close enough I suppose.

Second, we see that the DEM curve has some high-frequency oscillations. Those
are switchbacks that sample the DEM in a way that the DEM data is too coarse to
represent. The trail does not really oscillate like that, which is confirmed by
the GPS track. This effect would probably be mitigated with finer DEM data (1"
DEMs are available), but I haven't attempted this.

Third, we see that during the initial climb the DEM-derived elevation
consistently underreports the elevation. I suspect this is another artifact of
the coarseness of the DEM. If we're walking on a ridge, a bilinear interpolation
would take into account neighboring DEM pixels, which would be lower in
elevation (since it's a ridge). So on a ridge I would expect the DEM-derived
elevations to be under-reported, and in a canyon I'd expect them to be
over-reported. In this particular track, the initial climb and the initial
descent are on ridges, while the second climb is in a canyon. This brings us to
the next point.

The data in the second climb doesn't match /at all/. Here it's the GPS data
that's at fault. The canyon walls block the GPS signal, so GPS readings are
unreliable there.

So the grand conclusion of all this would appear to be that you can use 3" DEM
data to derive an elevation profile, but one should not expect this profile to
be terribly accurate. Still it's useful. Based purely on the DEM, I can see that
a round-trip on this route would entail 2800ft of net elevation gain. Seeing the
real track, this probably is an underestimate of ~200ft. Not bad.


[fn:1] The above analysis assumes that the implementation of the DEM sampler is
bug-free and that the DEM data is correct. While I don't know of any bugs, there
could be some. Same for the DEM data

** DONE X11 urgency hint and notifications                    :tools:desktop:
   CLOSED: [2014-03-19 Wed 00:20]

X11 has a common system for window notifications: the urgency hint. The relevant
section of the [[http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.2.4][ICCCM standard]]:

#+begin_quote
The UrgencyHint flag, if set in the flags field, indicates that the client deems
the window contents to be urgent, requiring the timely response of the user. The
window manager must make some effort to draw the user's attention to this window
while this flag is set.
#+end_quote

Some window managers are uncompliant and don't support this. Possibly as a
result, people really like to reinvent this particular wheel: [[http://www.linuxjournal.com/content/tech-tip-get-notifications-your-scripts-notify-send][notify-send]],
[[http://mattn.github.io/growl-for-linux/][growl]], and more. My WM ([[http://notion.sourceforge.net/][notion]]) /does/ support this very well, with some really
nice UI integration. Thus applications can request to be drawn as urgent. This
really begs for a commandline tool so shells can request the user's attention at
key points. For instance I really want to say something like

#+begin_src sh
make; seturgent
#+end_src

I.e. this would launch a source build, and when the build completes, this
particular terminal emulator window would request the user's attention. The
build could take a long, time, and the user may want to do stuff with the build
products, but in the meantime they can go do something else.

This =seturgent= tool didn't exist, so I wrote one:

#+CAPTION: =seturgent=
#+begin_src perl
#!/usr/bin/perl

# Copyright 2012,2013 Dima Kogan
# License: GPL 3 or later

use strict;
use warnings;
use feature qw(say);

use X11::Protocol;
use X11::Protocol::WM;
use X11::WindowHierarchy;

# if no arguments are given, sets urgency on the current window
#
# if an argument is given, uses it as a regex on the window name (all matches
# are set as urgent)

my $usage = "$0 [regex on the window name]";
die $usage if @ARGV > 1;


my $x = X11::Protocol->new()
  or die "Couldn't open display";

my @ids;
if( ! @ARGV )
{
  @ids = ($ENV{WINDOWID});
}
else
{
  my @windows = x11_filter_hierarchy( filter => qr{$ARGV[0]} )
    or die "No matching windows found";

  say "Found " . scalar(@windows) . " matching windows";
  @ids = map {$_->{id}} @windows;
}

foreach my $id(@ids)
{
  die "No window id" unless $id;
  X11::Protocol::WM::change_wm_hints( $x, $id,
                                      urgency => 1 );
}
#+end_src

This uses [[https://metacpan.org/pod/X11::WindowHierarchy][X11::WindowHierarchy]] to find the window, and [[https://metacpan.org/pod/X11::Protocol::WM][X11::Protocol::WM]] to set
the urgency hint. Both are available in Debian. Usage is very straightforward:
with no arguments, the current window is set urgent. Otherwise, the one and only
argument is treated like a regex on the window title. If a single match is
found, that window is set urgent.

Now I /can/ say

#+begin_src sh
make; seturgent
#+end_src
** DONE Already-running process notifications                 :tools:desktop:
   CLOSED: [2014-03-20 Thu 22:35]

The tool described in the last post ([[file:{lisp}(ob:link-to-post (ob:get-post-by-title "X11 urgency hint and notifications")){/lisp}][X11 urgency hint and notifications]]) works
well, but there's a common use case it does not support: completion notification
of already-running process. That post describes how to be notified when a build
completes:

#+begin_src sh
make; seturgent
#+end_src

But what if we already started the build? Another helper tool is required. Here
it is:

#+BEGIN_SRC sh

# As is, this can't be an external utility since it uses the shell builtin
# 'wait', which only works on direct children of this shell. An external utility
# creates another shell, so this doesn't work
function waitfor()
{
    # waits for a process to exit, and sets urgency when that happens. Expects a
    # single pgrep-able argument on the commandline. If no argument is given,
    # it'll look for the only child process.

    # if this process is a child of this shell, I use a blocking wait.
    # Otherwise, I poll.

    PID_ALL=$(pgrep -s0 -f $1)

    # filter out the current process (the shell) and 'xclip'. I have xclip
    # zombies apparently
    PID=$(comm -23 <(echo $PID_ALL | sort) <(echo $$ `pidof xclip` | xargs -n1 | sort))
    N=$(echo $PID | wc -w)

    if [[ $N -eq 1 ]]; then
        echo "Found unique process with pid $PID"
        kill -CONT $PID # resume this process, since it's almost certainly
                        # paused right now
        wait $PID;
        seturgent
    elif [[ $N -ne 0 ]]; then
        echo "Found more than one matching process. Doing nothing";
    elif [[ -z $1 ]]; then
        echo "No children of the current shell to wait on. Doing nothing";
    else
        echo "Found no matching processes in this shell. Looking globally.";
        PID=$(pgrep -f $1)
        N=$(echo $PID | wc -w)
        if [[ $N -eq 0 ]]; then
            echo "Found no matching global process either. Giving up.";
        elif [[ $N -ne 1 ]]; then
            echo "Found more than one global process. Giving up";
        else
            echo "Found unique process with pid $PID"
            while (ps -p $PID > /dev/null) { sleep 10; }
            seturgent;
        fi
    fi
}

#+END_SRC

This is a =zsh= shell script that lives in my =.zshrc=.

- with no argument, it acts on the only child of this shell
- with an argument, it uses =pgrep= to find a matching process, first in the
  local shell, then outside of the local shell

Once the target process is identified, the script waits for the process to exit,
then it sets the urgency hint on the terminal emulator window. If there's any
ambiguity about which process is being targeted, nothing is done.

The most common use case: if a long-running process is currently active, one
would temporarily suspend it with =C-z=, then issue a =waitfor=. This
re-activates the process, and sets the urgency when finished. One could also
re-implement the use case from the previous post as

#+begin_src sh
make & waitfor
#+end_src


As said previously, this is a =zsh= script. It probably needs to be tweaked a
little bit to work in =bash=, but I have not done this.

The reason this is a shell script, is that the wait-for-this-process-to-finish
operation on Linux only works from the parent of the process being waited on. As
implemented, =waitfor()= doesn't spawn a new process, and runs in the shell
process itself, which is the parent of the thing being waited on. If this was
anything other than a shell script, then the waiter would /also/ be a child of
the shell, so the process being waited on, and the process doing the waiting
would be /siblings/. The script works that case too, but it polls every 10
seconds, instead of being notified of completion.

I've been using this for a little bit. It's not perfect, and there're some warts
I'd like to fix. Still, it does the job, and it's already something I use every
day.

** DONE Cscope benchmarks                              :tools:dev:data:emacs:
   CLOSED: [2014-03-25 Tue 03:36]

I read and write lots of C code, and I find the [[http://cscope.sourceforge.net/][cscope]] tool to be invaluable in
searching and navigating code bases. Recently I took over maintership of the
[[https://github.com/dkogan/xcscope.el][xcscope.el]] Emacs interface to cscope. There are a surprising number of different
Emacs interfaces to cscope, and this one seems to be the most mature and
full-featured (and I made it much nicer).

One feature that some other interfaces have ([[http://lists.gnu.org/archive/html/gnu-emacs-sources/2008-04/msg00021.html][ascope]] for instance) is that
instead of running a new cscope process for each query, they leave the process
running, and reuse it for each query. This keeps the database in memory, and
doesn't waste cycles reloading it every time. This is the major feature of these
interfaces, and glorious performance benefits are claimed.

Currently =xcscope= does /not/ do this, and I sometimes consider implementing
this feature. It's going to be a pain to do, so I decided to run some tests to
see if the performance benefits really are worth it.

*** Benchmark machine

All tests were run on my relatively quick server. It has a quad-core Ivy bridge
Core-i5 CPU, 4GB of RAM and a non-SSD hard disk.

*** Test description

The code base under test is the linux kernel. This should be near the upper
bound of what most people would be indexing. Sure, larger projects exist, but
you're generally working on a contained piece, rather than the whole thing at
once (this is true of the kernel too, actually).

I perform multiple discrete cscope operations using the command-line tool. Each
operation starts a new =cscope= process, which reloads the database. I.e. I
perform the operation that's supposedly slow every time.

I measure how long it takes to build the search database, then to re-build it,
then to re-build it after =touch=-ing a file. Then I measure how long it takes
to run a search, then to re-run it, then to re-run it after =touch=-ing a file.

I do all this with the default settings, then again with settings more
appropriate for a kernel:

- /kernel mode/: =-k= option. Doesn't look in =/usr/include=
- /inverted-index mode/: =-q= option. Builds an extra index for faster searches

Each search is also run with the =-d= option. This only runs the search; it does
/not/ also update the database with each search. By default, cscope /does/
update the database with every search.

Specifically, I get the list of files with 

#+begin_src sh
cscope-indexer -l -r  
#+end_src

I build an index with

#+begin_src sh
cscope -b
#+end_src

If I'm indexing in kernel mode and I'm building an inverted index, I also pass
in =-q -k=. The test search looks for all uses of the =main= symbol:

#+begin_src sh
cscope -L0 main
#+end_src

Once again, if I'm indexing in kernel mode and I'm building an inverted index, I
also pass in =-q -k=. When I want to touch an arbitrary file, I do

#+begin_src sh
touch include/drm/drm_edid.h 
#+end_src

There's no significance to this file. It's just anything that's in the index.

As one can imagine, the disk cache plays a very significant role here, and
subsequent runs of the same command complete faster than the first. For this
reason all tests are run with both a cold cache (by dumping the disk cache prior
to the test) and a warm cache (/not/ dumping the cache, and pre-running the
operation a few times before timing). I also ran these tests on an actual hard
disk, and also on a tmpfs ramdisk.

All timings were performed multiple times, with the initial few values and the
outliers thrown out. The exact script used to collect the data is described and
available in the [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "GNU Global benchmarks")){/lisp}][next post]].

*** Results

All timings in seconds.

**** Cold disk cache

|                                              | Normal mode/ext3 | Kernel mode/ext3 | Normal mode/tmpfs | Kernel mode/tmpfs |
|----------------------------------------------+------------------+------------------+-------------------+-------------------|
| Initial database build                       |             45.9 |             80.2 |              14.0 |              44.2 |
| Database re-build after touching a file      |             10.4 |             48.9 |               3.2 |              30.1 |
| Initial search                               |              7.5 |              3.0 |               0.8 |              31.2 |
| Re-search after touching a file              |             12.7 |             43.7 |               3.5 |              32.1 |
| Initial no-db-update search                  |              5.3 |              0.8 |               0.8 |               0.8 |
| No-db-update re-search after touching a file |              5.1 |              0.8 |               0.7 |               0.8 |

**** Warm disk cache

|                                              | Normal mode/ext3 | Kernel mode/ext3 | Normal mode/tmpfs | Kernel mode/tmpfs |
|----------------------------------------------+------------------+------------------+-------------------+-------------------|
| Initial database build                       |             13.8 |             49.6 |              12.9 |              44.4 |
| Database re-build after touching a file      |              3.5 |             35.5 |               2.7 |              30.8 |
| Initial search                               |              0.8 |              0.1 |               0.8 |              30.8 |
| Re-search after touching a file              |              4.0 |             33.5 |               3.5 |              31.9 |
| Initial no-db-update search                  |              0.7 |              0.0 |               0.7 |               0.7 |
| No-db-update re-search after touching a file |              0.7 |              0.0 |               0.7 |               0.7 |

*** Conclusions

I've known about the cscope inverted index for a while, but never actually tried
to use it. Looks like it works as advertised: takes significantly longer to
build, but once built the speedup it provides is substantial. It would appear
that the main benefit of the inverted index is that less data needs to be read
from disk and /not/ that less searching is required. At least on this particular
test machine the inverted index has no upside if the data is all in RAM already
(tmpfs). On a slower box maybe we'd see the search times become significant, but
not here.

It's extremely clear that the overhead of just loading the database is
immaterial. It's effectively instant to load the database and then to run a
search in an inverted index with a warm cache. It's a bit slower without an
inverted index, but all the time there is spent searching, not loading the index
into memory. I know this because I get the same no-inverted-index search timings
with the cscope interactive tool, which loads the database just once. The only
way keeping the =cscope= process running is advantageous is if this makes it
more likely the caches stay warm. This is difficult to test, but I doubt it's
true. If I run repeated queries even with a new process every time, the data
stays cached, and things run quickly. What I think is much more likely is that
the people who wrote cscope interfaces such as =ascope= only used interfaces
such as =xcscope= without the =-d= option. I.e. they were updating the database
with every query, which clearly can be slow with a large codebase. Then they
were /not/ doing this with their persistent =cscope= sessions, and attributing
the performance gains to not loading the database rather than rebuilding the
index too often. In any case, I think it's pretty clear that this feature is not
worth the work, so I'm keeping =xcscope= as is.

** DONE GNU Global benchmarks                                :tools:data:dev:
   CLOSED: [2014-03-30 Sun 00:42]

The [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "Cscope benchmarks")){/lisp}][last post]] reports some performance numbers for [[http://cscope.sourceforge.net][cscope]]. There's another,
similar tool that I've been curious about: [[http://www.gnu.org/s/global/global.html][GNU global]]. It's like cscope in many
ways. It doesn't have some of the nicer cscope search types (caller, callee,
assignment, etc), and cscope works fine so I've never felt the need to move.
Since I just ran some cscope benchmarks, I thought it'd be interesting to run
the exact same tests with GNU global. Here I use the =gtags-cscope= frontend.
This is a compatibility layer in GNU global that has an identical interface to
cscope (among other things this makes it trivial to use =xcscope.el= with GNU
global).

*** Test description

The test conditions are the same as before. The testing in this /and/ the
previous post was performed by a script, which appears at the end of this post.
=gtags-cscope= doesn't have a separate inverted-index mode, so just a single
test appears here.

Here I'm using GNU global 6.2.10 built from source (upstream is in some sort of
fight with the Debian maintainer, so the packages are ancient). Cscope is 15.8a.

*** Results

All timings in seconds. Timings from the previous post are re-iterated for easy
comparison.

**** Cold disk cache

|                                              | Normal mode/ext3 | Kernel mode/ext3 | GNU Global/ext3 | Normal mode/tmpfs | Kernel mode/tmpfs | GNU Global/tmpfs |
|----------------------------------------------+------------------+------------------+-----------------+-------------------+-------------------+------------------|
| Initial database build                       |             45.9 |             80.2 |            84.1 |              14.0 |              44.2 |             14.0 |
| Database re-build after touching a file      |             10.4 |             48.9 |            26.8 |               3.2 |              30.1 |              0.7 |
| Initial search                               |              7.5 |              3.0 |            23.3 |               0.8 |              31.2 |              0.2 |
| Re-search after touching a file              |             12.7 |             43.7 |            28.4 |               3.5 |              32.1 |              0.7 |
| Initial no-db-update search                  |              5.3 |              0.8 |             0.1 |               0.8 |               0.8 |              0.0 |
| No-db-update re-search after touching a file |              5.1 |              0.8 |             0.1 |               0.7 |               0.8 |              0.0 |

**** Warm disk cache

|                                              | Normal mode/ext3 | Kernel mode/ext3 | GNU Global/ext3 | Normal mode/tmpfs | Kernel mode/tmpfs | GNU Global/tmpfs |
|----------------------------------------------+------------------+------------------+-----------------+-------------------+-------------------+------------------|
| Initial database build                       |             13.8 |             49.6 |            18.0 |              12.9 |              44.4 |             13.7 |
| Database re-build after touching a file      |              3.5 |             35.5 |             1.3 |               2.7 |              30.8 |              0.6 |
| Initial search                               |              0.8 |              0.1 |             0.4 |               0.8 |              30.8 |              0.2 |
| Re-search after touching a file              |              4.0 |             33.5 |             1.3 |               3.5 |              31.9 |              0.6 |
| Initial no-db-update search                  |              0.7 |              0.0 |             0.0 |               0.7 |               0.7 |              0.0 |
| No-db-update re-search after touching a file |              0.7 |              0.0 |             0.0 |               0.7 |               0.7 |              0.0 |

*** Conclusions

During *normal* use, we'd have a warm cache and we'd be using a real hard disk.
This is the bottom-left area of the timing tables. Those timings indicate that
GNU Global is much faster than cscope. Search performance appears to be on-par
with with an inverted-index-enabled cscope, but database build times only suffer
a little bit. This is interesting, and maybe would be worth switching to at some
point.

*** Benchmark script

All the timings were performed with the following =zsh= script. It uses some
=zsh=-isms, but could be converted to =bash= if somebody cares to do it.

#+begin_src sh
#!/bin/zsh

# needed in cleandb()
setopt nonomatch

function dropcaches() {
    if [[ $warmcold == "cold" ]]; then
        sync ;
        sudo sysctl -w vm.drop_caches=3;
    fi
    sleep 2;
}

function cleandb() {
    # requires nonomatch option to ignore missing globs
    rm -f cscope.out* G*;
}

function touchfile() {
    sleep 2; # very important. cscope needs this to see the file update
    touch include/drm/drm_edid.h;
}

TIMEFMT='%E'

awktally='
BEGIN {
  skip = ENVIRON["skip"]
}

/^[0-9\.]+s$/ {
  gsub("s","");
  str = str " " $1
  if( n >= skip )
  {
    sum += $1;
  }
  n++;
}

END {
  print ENVIRON["name"] ": skipping: " skip " all: " str " mean: " sum/(n-skip)
}'

typeset -A skipcounts
skipcounts=(cold 2 warm 2)

typeset -A modeoptions
modeoptions=(normal "" kernel "-k -q")

cscope-indexer -l -r

Nrepeat=8

for mode (normal kernel global)
{
    if [[ $mode == "global" ]]; then
        cmd="gtags-cscope";
    else
        cmd="cscope $modeoptions[$mode]";
    fi

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial build; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                else
                    cleandb;
                fi
                dropcaches;
                time ${(z)cmd} -b;
            } |& awk $awktally
        }
    }

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial search; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                fi
                dropcaches;
                time ${(z)cmd} -L0 main > /dev/null;
            } |& awk $awktally
        }
    }

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial no-db search; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                fi
                dropcaches;
                time ${(z)cmd} -d -L0 main > /dev/null;
            } |& awk $awktally
        }
    }
}
#+end_src

*** benchmark data                                                 :noexport:
**** ext3
cold initial build; normal mode; touching: 0: skipping: 2 all:  45.91 44.30 45.80 45.82 45.18 45.99 44.65 49.29 45.90 44.61 mean: 45.905
warm initial build; normal mode; touching: 0: skipping: 2 all:  14.27 13.67 14.25 14.24 14.27 13.24 13.23 13.56 14.71 13.21 mean: 13.8388
cold initial build; normal mode; touching: 1: skipping: 2 all:  9.87 9.78 10.00 9.85 9.99 13.60 9.97 9.91 10.04 10.01 mean: 10.4213
warm initial build; normal mode; touching: 1: skipping: 2 all:  3.41 3.42 3.83 3.19 3.47 3.75 3.35 3.19 3.43 3.65 mean: 3.4825
cold initial search; normal mode; touching: 0: skipping: 2 all:  7.12 7.09 7.12 7.20 7.15 7.20 7.08 10.33 7.14 7.12 mean: 7.5425
warm initial search; normal mode; touching: 0: skipping: 2 all:  0.83 0.82 0.82 0.82 0.83 0.83 0.82 0.82 0.82 0.82 mean: 0.8225
cold initial search; normal mode; touching: 1: skipping: 2 all:  11.97 11.81 11.79 12.29 14.96 13.74 12.29 12.13 12.11 12.08 mean: 12.6737
warm initial search; normal mode; touching: 1: skipping: 2 all:  3.99 4.01 3.90 4.01 3.99 3.91 4.10 4.05 3.84 3.96 mean: 3.97
cold initial no-db search; normal mode; touching: 0: skipping: 2 all:  6.06 4.06 6.15 4.16 8.56 4.07 5.71 4.05 5.79 4.07 mean: 5.32
warm initial no-db search; normal mode; touching: 0: skipping: 2 all:  0.75 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 mean: 0.74
cold initial no-db search; normal mode; touching: 1: skipping: 2 all:  5.74 4.07 5.80 4.05 5.80 4.05 6.96 4.07 5.80 4.05 mean: 5.0725
warm initial no-db search; normal mode; touching: 1: skipping: 2 all:  0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.75 0.74 mean: 0.74125
cold initial build; kernel mode; touching: 0: skipping: 2 all:  79.45 79.86 79.10 85.14 79.02 79.01 78.37 83.88 78.54 78.48 mean: 80.1925
warm initial build; kernel mode; touching: 0: skipping: 2 all:  67.54 54.28 51.28 48.01 48.80 50.04 49.71 50.04 49.12 49.78 mean: 49.5975
cold initial build; kernel mode; touching: 1: skipping: 2 all:  49.06 48.46 49.80 52.14 46.29 46.43 51.68 47.65 49.56 47.30 mean: 48.8563
warm initial build; kernel mode; touching: 1: skipping: 2 all:  47.38 37.87 36.10 38.85 35.39 34.04 33.23 37.30 33.47 35.28 mean: 35.4575
cold initial search; kernel mode; touching: 0: skipping: 2 all:  2.69 2.74 2.82 4.07 2.78 2.87 2.84 2.86 2.82 2.82 mean: 2.985
warm initial search; kernel mode; touching: 0: skipping: 2 all:  0.11 0.09 0.09 0.09 0.09 0.09 0.09 0.09 0.09 0.09 mean: 0.09
cold initial search; kernel mode; touching: 1: skipping: 2 all:  49.42 47.28 45.30 42.83 43.94 41.10 42.96 47.20 43.05 43.23 mean: 43.7013
warm initial search; kernel mode; touching: 1: skipping: 2 all:  36.59 33.33 33.77 32.52 34.47 32.23 32.93 33.60 34.35 33.92 mean: 33.4738
cold initial no-db search; kernel mode; touching: 0: skipping: 2 all:  1.15 0.56 0.94 0.62 0.92 0.61 1.05 0.61 0.93 0.59 mean: 0.78375
warm initial no-db search; kernel mode; touching: 0: skipping: 2 all:  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 mean: 0
cold initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.90 1.28 0.91 0.59 0.94 0.59 0.87 0.61 0.94 0.61 mean: 0.7575
warm initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 mean: 0
cold initial build; global mode; touching: 0: skipping: 2 all:  86.15 83.39 84.38 86.24 85.76 81.48 82.46 85.79 84.17 82.54 mean: 84.1025
warm initial build; global mode; touching: 0: skipping: 2 all:  17.76 18.55 17.78 17.69 18.22 18.95 17.53 17.69 18.08 17.71 mean: 17.9563
cold initial build; global mode; touching: 1: skipping: 2 all:  26.69 30.73 27.52 25.89 26.93 25.70 25.73 25.89 29.63 27.17 mean: 26.8075
warm initial build; global mode; touching: 1: skipping: 2 all:  1.32 1.31 1.31 1.31 1.38 1.36 1.32 1.31 1.30 1.27 mean: 1.32
cold initial search; global mode; touching: 0: skipping: 2 all:  23.03 26.28 24.50 22.10 23.01 22.02 22.10 23.34 22.46 26.58 mean: 23.2638
warm initial search; global mode; touching: 0: skipping: 2 all:  0.38 0.37 0.36 0.37 0.37 0.36 0.36 0.36 0.36 0.36 mean: 0.3625
cold initial search; global mode; touching: 1: skipping: 2 all:  27.16 26.11 27.19 30.34 27.49 28.63 28.26 27.84 29.41 27.84 mean: 28.375
warm initial search; global mode; touching: 1: skipping: 2 all:  1.35 1.30 1.28 1.31 1.31 1.29 1.31 1.30 1.31 1.33 mean: 1.305
cold initial no-db search; global mode; touching: 0: skipping: 2 all:  1.39 0.82 1.07 0.63 0.21 0.07 0.05 0.04 0.06 0.05 mean: 0.2725
warm initial no-db search; global mode; touching: 0: skipping: 2 all:  0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 mean: 0.01
cold initial no-db search; global mode; touching: 1: skipping: 2 all:  0.05 0.04 0.03 0.05 0.04 0.04 1.90 0.41 0.22 0.03 mean: 0.34
warm initial no-db search; global mode; touching: 1: skipping: 2 all:  0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 mean: 0.01

**** tmpfs
cold initial build; normal mode; touching: 0: skipping: 2 all:  14.07 14.11 14.15 13.99 13.94 14.01 14.20 14.01 14.02 14.06 mean: 14.0475
warm initial build; normal mode; touching: 0: skipping: 2 all:  12.99 12.97 12.82 12.98 12.89 13.02 12.87 12.93 13.00 12.92 mean: 12.9287
cold initial build; normal mode; touching: 1: skipping: 2 all:  3.19 3.21 3.16 3.17 3.17 3.20 3.17 3.19 3.16 3.20 mean: 3.1775
warm initial build; normal mode; touching: 1: skipping: 2 all:  2.72 2.73 2.72 2.72 2.72 2.73 2.72 2.72 2.72 2.72 mean: 2.72125
cold initial search; normal mode; touching: 0: skipping: 2 all:  1.00 0.85 0.86 0.83 0.84 0.84 0.84 0.84 0.84 0.84 mean: 0.84125
warm initial search; normal mode; touching: 0: skipping: 2 all:  0.85 0.82 0.82 0.83 0.82 0.82 0.82 0.82 0.82 0.82 mean: 0.82125
cold initial search; normal mode; touching: 1: skipping: 2 all:  3.86 3.66 3.53 3.51 3.50 3.54 3.50 3.50 3.51 3.54 mean: 3.51625
warm initial search; normal mode; touching: 1: skipping: 2 all:  3.47 3.46 3.45 3.45 3.46 3.46 3.46 3.45 3.45 3.45 mean: 3.45375
cold initial no-db search; normal mode; touching: 0: skipping: 2 all:  0.77 0.74 0.75 0.75 0.75 0.75 0.75 0.75 0.80 0.74 mean: 0.755
warm initial no-db search; normal mode; touching: 0: skipping: 2 all:  0.75 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 mean: 0.74
cold initial no-db search; normal mode; touching: 1: skipping: 2 all:  0.75 0.74 0.74 0.74 0.74 0.74 0.75 0.75 0.76 0.76 mean: 0.7475
warm initial no-db search; normal mode; touching: 1: skipping: 2 all:  0.76 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 mean: 0.74
cold initial build; kernel mode; touching: 0: skipping: 2 all:  41.84 44.43 45.34 44.74 43.31 43.62 43.44 44.84 43.48 44.99 mean: 44.22
warm initial build; kernel mode; touching: 0: skipping: 2 all:  44.53 43.35 45.38 42.49 44.83 43.90 44.55 43.17 46.30 44.33 mean: 44.3687
cold initial build; kernel mode; touching: 1: skipping: 2 all:  30.15 29.48 29.68 29.75 30.45 29.80 30.18 30.34 30.11 30.74 mean: 30.1313
warm initial build; kernel mode; touching: 1: skipping: 2 all:  29.93 30.82 30.61 29.85 30.34 29.70 31.60 32.37 30.68 31.20 mean: 30.7937
cold initial search; kernel mode; touching: 0: skipping: 2 all:  33.00 31.38 31.03 31.81 31.35 31.12 31.17 32.33 30.26 30.48 mean: 31.1937
warm initial search; kernel mode; touching: 0: skipping: 2 all:  31.13 30.00 29.20 31.73 30.28 29.70 31.97 29.27 33.26 30.98 mean: 30.7987
cold initial search; kernel mode; touching: 1: skipping: 2 all:  31.60 30.70 30.90 32.33 33.94 31.82 31.68 31.33 33.09 31.56 mean: 32.0812
warm initial search; kernel mode; touching: 1: skipping: 2 all:  30.97 31.27 31.32 31.26 32.95 32.07 31.94 31.14 33.00 31.56 mean: 31.905
cold initial no-db search; kernel mode; touching: 0: skipping: 2 all:  0.88 0.74 0.78 0.74 0.78 0.79 0.74 0.75 0.77 0.76 mean: 0.76375
warm initial no-db search; kernel mode; touching: 0: skipping: 2 all:  0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 0.74 mean: 0.74
cold initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.77 0.75 0.74 0.74 0.93 0.78 0.77 0.74 0.77 0.75 mean: 0.7775
warm initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.74 0.74 0.74 0.74 0.74 0.76 0.74 0.74 0.74 0.74 mean: 0.7425
cold initial build; global mode; touching: 0: skipping: 2 all:  14.25 13.88 14.12 14.73 13.99 13.60 13.74 14.55 13.79 13.67 mean: 14.0238
warm initial build; global mode; touching: 0: skipping: 2 all:  13.47 13.53 13.78 13.59 13.85 14.02 13.43 13.68 13.59 13.99 mean: 13.7412
cold initial build; global mode; touching: 1: skipping: 2 all:  0.96 0.64 0.64 0.61 0.62 0.60 0.63 0.96 0.89 0.65 mean: 0.7
warm initial build; global mode; touching: 1: skipping: 2 all:  0.59 0.59 0.59 0.59 0.59 0.59 0.59 0.59 0.59 0.59 mean: 0.59
cold initial search; global mode; touching: 0: skipping: 2 all:  0.62 0.28 0.20 0.22 0.20 0.22 0.21 0.20 0.20 0.20 mean: 0.20625
warm initial search; global mode; touching: 0: skipping: 2 all:  0.19 0.19 0.19 0.19 0.19 0.19 0.19 0.19 0.19 0.19 mean: 0.19
cold initial search; global mode; touching: 1: skipping: 2 all:  0.61 0.60 0.60 0.60 0.60 0.60 0.61 0.63 0.96 0.69 mean: 0.66125
warm initial search; global mode; touching: 1: skipping: 2 all:  0.60 0.59 0.59 0.59 0.59 0.59 0.59 0.61 0.59 0.59 mean: 0.5925
cold initial no-db search; global mode; touching: 0: skipping: 2 all:  0.08 0.05 0.04 0.02 0.06 0.05 0.03 0.02 0.04 0.17 mean: 0.05375
warm initial no-db search; global mode; touching: 0: skipping: 2 all:  0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 mean: 0.01
cold initial no-db search; global mode; touching: 1: skipping: 2 all:  0.09 0.07 0.05 0.02 0.02 0.02 0.02 0.04 0.06 0.04 mean: 0.03375
warm initial no-db search; global mode; touching: 1: skipping: 2 all:  0.02 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 mean: 0.01


**** Ext3-only data in a table, with formulas

ext3-only:
|                                              |       |       |       |       |       |       |       |       |       |       |     mean | stdev/mean |       |       |       |       |       |       |       |       |       |       |     mean |          stdev/mean |
|----------------------------------------------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+----------+------------+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+----------+---------------------|
| Initial database build                       | 45.91 | 44.30 | 45.80 | 45.82 | 45.18 | 45.99 | 44.65 | 49.29 | 45.90 | 44.61 |   45.905 |          3 | 14.27 | 13.67 | 14.25 | 14.24 | 14.27 | 13.24 | 13.23 | 13.56 | 14.71 | 13.21 | 13.83875 |                   4 |
| Database re-build after touching a file      |  9.87 |  9.78 | 10.00 |  9.85 |  9.99 | 13.60 |  9.97 |  9.91 | 10.04 | 10.01 | 10.42125 |         12 |  3.41 |  3.42 |  3.83 |  3.19 |  3.47 |  3.75 |  3.35 |  3.19 |  3.43 |  3.65 |   3.4825 |                   7 |
| Initial search                               |  7.12 |  7.09 |  7.12 |  7.20 |  7.15 |  7.20 |  7.08 | 10.33 |  7.14 |  7.12 |   7.5425 |         15 |  0.83 |  0.82 |  0.82 |  0.82 |  0.83 |  0.83 |  0.82 |  0.82 |  0.82 |  0.82 |   0.8225 |                   1 |
| Re-searchafter touching a file               | 11.97 | 11.81 | 11.79 | 12.29 | 14.96 | 13.74 | 12.29 | 12.13 | 12.11 | 12.08 | 12.67375 |          9 |  3.99 |  4.01 |  3.90 |  4.01 |  3.99 |  3.91 |  4.10 |  4.05 |  3.84 |  3.96 |     3.97 |                   2 |
| Initial no-db-update search                  |  6.06 |  4.06 |  6.15 |  4.16 |  8.56 |  4.07 |  5.71 |  4.05 |  5.79 |  4.07 |     5.32 |         30 |  0.75 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |     0.74 |                   0 |
| No-db-update re-search after touching a file |  5.74 |  4.07 |  5.80 |  4.05 |  5.80 |  4.05 |  6.96 |  4.07 |  5.80 |  4.05 |   5.0725 |         23 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.74 |  0.75 |  0.74 |  0.74125 |                   0 |
| Initial database build                       | 79.45 | 79.86 | 79.10 | 85.14 | 79.02 | 79.01 | 78.37 | 83.88 | 78.54 | 78.48 |  80.1925 |          3 | 67.54 | 54.28 | 51.28 | 48.01 | 48.80 | 50.04 | 49.71 | 50.04 | 49.12 | 49.78 |  49.5975 |                   2 |
| Database re-build after touching a file      | 49.06 | 48.46 | 49.80 | 52.14 | 46.29 | 46.43 | 51.68 | 47.65 | 49.56 | 47.30 | 48.85625 |          5 | 47.38 | 37.87 | 36.10 | 38.85 | 35.39 | 34.04 | 33.23 | 37.30 | 33.47 | 35.28 |  35.4575 |                   5 |
| Initial search                               |  2.69 |  2.74 |  2.82 |  4.07 |  2.78 |  2.87 |  2.84 |  2.86 |  2.82 |  2.82 |    2.985 |         15 |  0.11 |  0.09 |  0.09 |  0.09 |  0.09 |  0.09 |  0.09 |  0.09 |  0.09 |  0.09 |     0.09 |                   0 |
| Re-searchafter touching a file               | 49.42 | 47.28 | 45.30 | 42.83 | 43.94 | 41.10 | 42.96 | 47.20 | 43.05 | 43.23 | 43.70125 |          4 | 36.59 | 33.33 | 33.77 | 32.52 | 34.47 | 32.23 | 32.93 | 33.60 | 34.35 | 33.92 | 33.47375 |                   2 |
| Initial no-db-update search                  |  1.15 |  0.56 |  0.94 |  0.62 |  0.92 |  0.61 |  1.05 |  0.61 |  0.93 |  0.59 |  0.78375 |         25 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |       0. | nint((0. / 0.) 100) |
| No-db-update re-search after touching a file |  0.90 |  1.28 |  0.91 |  0.59 |  0.94 |  0.59 |  0.87 |  0.61 |  0.94 |  0.61 |   0.7575 |         22 |  0.01 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |  0.00 |       0. | nint((0. / 0.) 100) |
| Initial database build                       | 86.15 | 83.39 | 84.38 | 86.24 | 85.76 | 81.48 | 82.46 | 85.79 | 84.17 | 82.54 |  84.1025 |          2 | 17.76 | 18.55 | 17.78 | 17.69 | 18.22 | 18.95 | 17.53 | 17.69 | 18.08 | 17.71 | 17.95625 |                   3 |
| Database re-build after touching a file      | 26.69 | 30.73 | 27.52 | 25.89 | 26.93 | 25.70 | 25.73 | 25.89 | 29.63 | 27.17 |  26.8075 |          5 |  1.32 |  1.31 |  1.31 |  1.31 |  1.38 |  1.36 |  1.32 |  1.31 |  1.30 |  1.27 |     1.32 |                   3 |
| Initial search                               | 23.03 | 26.28 | 24.50 | 22.10 | 23.01 | 22.02 | 22.10 | 23.34 | 22.46 | 26.58 | 23.26375 |          7 |  0.38 |  0.37 |  0.36 |  0.37 |  0.37 |  0.36 |  0.36 |  0.36 |  0.36 |  0.36 |   0.3625 |                   1 |
| Re-searchafter touching a file               | 27.16 | 26.11 | 27.19 | 30.34 | 27.49 | 28.63 | 28.26 | 27.84 | 29.41 | 27.84 |   28.375 |          4 |  1.35 |  1.30 |  1.28 |  1.31 |  1.31 |  1.29 |  1.31 |  1.30 |  1.31 |  1.33 |    1.305 |                   1 |
| Initial no-db-update search                  |  1.39 |  0.82 |  1.07 |  0.63 |  0.21 |  0.07 |  0.05 |  0.04 |  0.06 |  0.05 |   0.2725 |        139 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |     0.01 |                   0 |
| No-db-update re-search after touching a file |  0.05 |  0.04 |  0.03 |  0.05 |  0.04 |  0.04 |  1.90 |  0.41 |  0.22 |  0.03 |     0.34 |        190 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |  0.01 |     0.01 |                   0 |
#+TBLFM: $12=vmean($4..$11)::$13=round((vsdev($4..$11)/$12)*100)::$24=vmean($16..$23)::$25=round((vsdev($16..$23)/$24)*100)

**** Final table; mean-only, outliers removed

Data order same as before:
| Initial database build                       |
| Database re-build after touching a file      |
| Initial search                               |
| Re-searchafter touching a file               |
| Initial no-db-update search                  |
| No-db-update re-search after touching a file |


|        | Cold cache | Warm cache |
|--------+------------+------------|
| Normal |       45.9 |       13.8 |
| ext3   |       10.4 |        3.5 |
|        |        7.5 |        0.8 |
|        |       12.7 |        4.0 |
|        |        5.3 |        0.7 |
|        |        5.1 |        0.7 |
|--------+------------+------------|
| Kernel |       80.2 |       49.6 |
| ext3   |       48.9 |       35.5 |
|        |        3.0 |        0.1 |
|        |       43.7 |       33.5 |
|        |        0.8 |        0.0 |
|        |        0.8 |        0.0 |
|--------+------------+------------|
| Global |       84.1 |       18.0 |
| ext3   |       26.8 |        1.3 |
|        |       23.3 |        0.4 |
|        |       28.4 |        1.3 |
|        |        0.1 |        0.0 |
|        |        0.1 |        0.0 |
|--------+------------+------------|
| Normal |       14.0 |       12.9 |
| tmpfs  |        3.2 |        2.7 |
|        |        0.8 |        0.8 |
|        |        3.5 |        3.5 |
|        |        0.8 |        0.7 |
|        |        0.7 |        0.7 |
|--------+------------+------------|
| Kernel |       44.2 |       44.4 |
| tmpfs  |       30.1 |       30.8 |
|        |       31.2 |       30.8 |
|        |       32.1 |       31.9 |
|        |        0.8 |        0.7 |
|        |        0.8 |        0.7 |
|--------+------------+------------|
| Global |       14.0 |       13.7 |
| tmpfs  |        0.7 |        0.6 |
|        |        0.2 |        0.2 |
|        |        0.7 |        0.6 |
|        |        0.0 |        0.0 |
|        |        0.0 |        0.0 |

** DONE Running qemu with a custom kernel on ARM                  :tools:dev:
   CLOSED: [2014-04-07 Mon 23:38]

So I was porting [[http://www.sysdig.org][sysdig]] to ARM, and needed a target device to test the progress.
Sysdig uses syscall tracepoints, which were added to Linux relatively recently,
in version 3.7. Thus the ARM devices I had lying around were too old, and thus
weren't suitable to test on (I could forward port the kernel patches that make
them work, but this would be too much of a tangential effort).

The solution I settled on was emulation. Qemu can run in /system/ mode to
emulate a full machine. Specific instructions on how to run a vanilla-ish Debian
system with a custom kernel were hard to find, so I'm documenting them here.
Aurlien Jarno has disk images of a fresh Debian install and kernel images for
Qemu emulation here: http://people.debian.org/~aurel32/qemu/armel/. This is the
=armel= images, but he has the other arches as well.

Those images work fine. I just need to run a custom kernel I build myself.
Aurlien provides the kernel image /and/ an init ramdisk. It's not immediately
clear how to build this =initrd= image (and my various attempts weren't
fruitful). It was also not obvious how to run without =initrd=. The solution
that worked for me in the end was a monolithic kernel (all necessary drivers
compiled in) and a particular set of qemu options to workwithout a ramdisk.

I built a vanilla Linux 3.14 kernel =zImage=. The multiarch cross-toolchain
isn't in Debian proper yet, but packages are available from
http://people.debian.org/~wookey/tools/debian/.

The [[file:files/kernelstuff/versatile.config][kernel config]] was based off the vanilla =versatile_defconfig=, with a few
drivers and things built in. As usual, the kernel can be built with something
like this:

#+begin_src sh
cd linux
git reset --hard v3.14
cp /tmp/versatile.config .config
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4 zImage
#+end_src

This produces an image in =arch/arm/boot/zImage=. Everything I care about is
built-in, so I don't care about shipping modules, or building a ramdisk. A qemu
command to use this:

#+begin_src sh
qemu-system-arm -M versatilepb -kernel ~/linux/arch/arm/boot/zImage -hda debian_wheezy_armel_standard.qcow2 -append "noinitrd root=/dev/sda1 rw"
#+end_src

This appears to boot successfully, mounting everything, bringing up the network,
etc. There is a benign warning about not being able to talk to the modules from
the original kernel, but I obviously don't care. By default =eth0= is at
=10.0.2.15= with the host machine reachable at =10.0.2.2=.

** DONE Reading DWARF prototypes in ltrace                        :tools:dev:
   CLOSED: [2014-04-14 Mon 02:51]

From time to time I use the [[http://ltrace.org/][=ltrace=]] tool for introspection into user-space
processes. This is similar to =strace=, but hooks into library API calls intead
of just system calls. This is quite useful, but has some extra challenges.

With system calls you know beforehand the full set of functions you are hooking,
their prototypes, and the meaning and purpose of each argument. With general
libraries the space of all the possible APIs is huge, so you generally do /not/
know this. =ltrace= can read configuration files that define these interfaces,
so with a bit of manual effort you can provide this information. It would be
really nice to be able to trace generic function calls with no extra effort at
all. Much of the prototype data exists in debug infomation, which is often
available along with the executable binary. So by parsing this information, we
can trace API calls without needing to edit a configuration file.

*** Stock behavior

Let's say I have the following simple project. There are 3 files: =tstlib.h=,
=tstlib.c= and =tst.c=. These define a small library and an application
respectively. Let's say I have

=tstlib.h=
#+begin_src C
#pragma once

struct tree
{
    int x;
    struct tree* left;
    struct tree* right;
};
struct tree treetest(struct tree* t);

struct loop_a;
struct loop_b;
typedef struct loop_a { struct loop_b*   b; int x;} loop_a_t;
        struct loop_b {        loop_a_t* a; int x;};
void looptest( loop_a_t* a );

enum E { A,B,C };
typedef enum E E_t;
int enumtest( enum E a, E_t b );

struct witharray
{
    double x[5];
};
double arraytest( struct witharray* s );
#+end_src

=tstlib.c=
#+begin_src C
#include "tstlib.h"

struct tree treetest(struct tree* t)
{
    if(t->left  != NULL) treetest(t->left);
    if(t->right != NULL) treetest(t->right);
    t->x++;

    return *t;
}

void looptest( loop_a_t* a )
{
    a->x++;
    a->b->x++;
}

int enumtest( enum E a, E_t b )
{
    return a == b;
}

double arraytest( struct witharray* s )
{
    return s->x[0];
}
#+end_src

=tst.c=
#+begin_src C
#include "tstlib.h"
#include <unistd.h>

void main(void)
{
    struct tree d = {.x = 4};
    struct tree c = {.x = 3, .right = &d};
    struct tree b = {.x = 2};
    struct tree a = {.x = 1, .left = &b, .right = &c};
    treetest( &a );

    struct loop_a la = {.x = 5};
    struct loop_b lb = {.x = 6};
    la.b = &lb;
    lb.a = &la;
    looptest(&la);

    enum E ea = A, eb = B;
    enumtest( ea, eb );

    struct witharray s = {.x = {1.0,2.0,1.0,2.0,1.0}};
    arraytest( &s );
}
#+end_src

Now I build this with debug information, placing the library in a DSO and
setting the RPATH:

#+begin_src sh
cc -g -c -o tst.o tst.c
cc -fpic -g -c -o tstlib.o tstlib.c
cc -shared -Wl,-rpath=/home/dima/projects/ltrace/ltracetests -o tstlib.so  tstlib.o
cc -Wl,-rpath=/home/dima/projects/ltrace/ltracetests tst.o tstlib.so -o tst
#+end_src

I now run the stock =ltrace= to see calls into the =tstlib= library. I'm using
the latest =ltrace= in Debian/sid: version 0.7.3-4:

#+begin_src sh
dima@shorty:~/projects/ltrace/ltracetests$ ltrace -n2 -l tstlib.so ./tst

tst->treetest(0x7fff6b36ad30, 0x7fff6b36ada0, 0x7fff6b36ada0, 0 <unfinished ...>
  tstlib.so->treetest(0x7fff6b36acf0, 0x7fff6b36adc0, 0x7fff6b36adc0, 0) = 0
  tstlib.so->treetest(0x7fff6b36acf0, 0x7fff6b36ade0, 0x7fff6b36ade0, 0 <unfinished ...>
    tstlib.so->treetest(0x7fff6b36acb0, 0x7fff6b36ae00, 0x7fff6b36ae00, 0) = 0
  <... treetest resumed> )                                            = 0x7fff6b36acb0
<... treetest resumed> )                                              = 0x7fff6b36ad30
tst->looptest(0x7fff6b36ad90, 0x7fff6b36ae00, 0x7fff6b36ade0, 0x7fff6b36adc0) = 0x7fff6b36ad80
tst->enumtest(0, 1, 1, 0x7fff6b36adc0)                                = 0
tst->arraytest(0x7fff6b36ad50, 1, 1, 0x7fff6b36adc0)                  = 0x3ff0000000000000
+++ exited (status 0) +++
#+end_src

So we clearly see the calls, but the meaning of the arguments (and return
values) isn't clear. This is because =ltrace= has no idea what the prototypes of
anything are, and assumes that every API call is =long f(long,long,long,long)=.

*** Patched behavior

I made a patch to read in the prototypes from DWARF debugging information. The
initial version lives at https://github.com/dkogan/ltrace. This is far from
done, but it's enough to evaluate the core functionality. With the patched
=ltrace=:

#+begin_src sh
dima@shorty:~/projects/ltrace/ltracetests$ ltrace -n2 -l tstlib.so ./tst

tst->treetest({ 1, { 2, nil, nil }, { 3, nil, { 4, nil, nil } } } <unfinished ...>
  tstlib.so->treetest({ 2, nil, nil })                                = nil
  tstlib.so->treetest({ 3, nil, { 4, nil, nil } } <unfinished ...>
    tstlib.so->treetest({ 4, nil, nil })                              = nil
  <... treetest resumed> )                                            = { 5, nil, nil }
<... treetest resumed> )                                              = { 2, { 3, nil, nil }, { 4, nil, { 5, nil, nil } } }
tst->looptest({ { recurse^, 6 }, 5 })                                 = <void>
tst->enumtest(A, B)                                                   = 0
tst->arraytest({ [ 1.000000, 2.000000, 1.000000, 2.000000... ] })     = 1.000000
+++ exited (status 0) +++
#+end_src

Much better! We see the tree structure, the array and the enum values. The
return values make sense too. So this is potentially very useful.

*** Issues to resolve

Playing with this for a bit, it's becoming more clear what the issues are. The
DWARF information gives you the prototype, but an API definition is more than
just a prototype. For one thing, if a function has a pointer argument, this can
represent and input or an output. My implementation currently assumes it's an
input, but being wrong either way is problematic here:

- If a pointer is an output and ltrace interprets it as an input, then the
  output is never printed (as we can see in the loop test above). Furthermore,
  the input /will/ be printed and since there could be nested pointers, this
  could result in a segmentation fault. In this case =ltrace= can thus crash the
  process being instrumented. Oof.

- If a pointer is an input treated as an output, then again, we won't see useful
  information, and will be printing potentially bogus data at the output.

This can be remedied somewhat by assuming that an input /must/ be =const= (and
vice versa), but one can't assume that across the board.

Even if we somehow know that a pointer is an input, we still don't know how to
print it. How many integers does an =int*= point to? Currently I assume the
answer is 1, but what if it's not? Guessing too low we don't print enough useful
information; guessing too high can overrun our memory.

These are all things that =ltrace='s configuration files can take care of. So it
sounds to me like the best approach is a joint system, where both DWARF and the
config files are read in, and complementary definitions are used. It wouldn't be
fully automatic, but at least it could be /right/. In theory this is implemented
in the tree I linked to above, but it doesn't work yet.

This all needs a bit more thought, but I think I'm on to something.

** DONE Argument alignment in Linux system calls                  :tools:dev:
   CLOSED: [2014-04-16 Wed 02:08]

The last two posts talked about patches to =sysdig= and =ltrace=. This week
wouldn't be complete without patching =strace= as well. My patch series to make
=sysdig= work on ARM apparently had a bug: =preadv= and =pwritev= were not
reporting their =offset= argument properly. These two syscalls had the same
exact issue, so I'll just talk about =preadv=. The userspace prototype of this
syscall looks like this:

#+begin_src C
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset);
#+end_src

=off_t= is a 64-bit value, so on 32-bit architectures this must be split across
two different registers when making the syscall. Some architectures also have
alignment requirements. In my case, the Linux ARM EABI requires that such values
be passed in a consecutive even/odd register pair, with a register of padding if
needed. Thus in the case of =preadv=, the values would be passed as follows:

| argument  | register |
|-----------+----------|
| fd        | r0       |
| iov       | r1       |
| iovcnt    | r2       |
| *padding* | r3       |
| offset    | r4/r5    |

The sysdig ARM code was doing this, and it worked fine for other syscalls, but
this was /not/ working for =preadv= and =pwritev=. To my surprise I discovered
that even =strace= was misreporting the value of the =offset= argument. I wrote
a small test program:

#+begin_src C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/uio.h>

int main(void)
{
    const off_t offset = 1234567890123456789LL;
    char buf[4];

    int fd_zero = open("/dev/zero", O_RDONLY);
    pread (fd_zero, buf, sizeof(buf), offset);
    preadv(fd_zero,
           &(struct iovec){ .iov_base = buf,
                   .iov_len = sizeof(buf)},
           1, offset );

    int fd_null = open("/dev/null", O_WRONLY);
    pwrite(fd_null, buf, sizeof(buf), offset);
    pwritev(fd_null,
            &(struct iovec){.iov_base = buf, .iov_len = sizeof(buf)},
            1, offset );

    return 0;
}
#+end_src

Then I built it with =gcc -std=gnu99 -D_FILE_OFFSET_BITS=64=, and ran it under
=strace= on ARM. The relevant parts of =strace= output:

#+begin_src C
open("/dev/zero", O_RDONLY|O_LARGEFILE) = 3
pread(3, "\0\0\0\0", 4, 1234567890123456789) = 4
preadv(3, [{"\0\0\0\0", 4}], 1, 4582412532) = 4
open("/dev/null", O_WRONLY|O_LARGEFILE) = 4
pwrite(4, "\0\0\0\0", 4, 1234567890123456789) = 4
pwritev(4, [{"\0\0\0\0", 4}], 1, 4582412532) = 4
#+end_src

Note that the =offset= parameter in =preadv= and =pwritev= is reported
as 4582412532. As you can see in the source, the offset is actually the same for
all the calls: 1234567890123456789. So something fishy is going on. Digging
through kernel source revealed the answer. Here's how the =pread= and =preadv=
system calls are defined (I'm looking at =fs/read_write.c= in Linux 3.14):

#+begin_src C
SYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,
			size_t, count, loff_t, pos)
SYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,
		unsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)
#+end_src

Note that =pread= defines its =pos= argument as a 64-bit value of type =loff_t=.
This is what you'd expect and also what the userspace =pread= prototype looks
like. Now look at =preadv=. It does /not/ have a 64-bit =pos= argument. Instead
it has two separate 32-bit arguments. This is /different/ from the userspace
prototype! So as far as the kernel is concerned, there are no 64 bit arguments
here, so no alignment requirements apply. So the /actual/ register map in the
=preadv= syscall looks like

| argument  | register |
|-----------+----------|
| fd        | r0       |
| iov       | r1       |
| iovcnt    | r2       |
| offset    | r3/r4    |

So libc must know to do this translation when invoking the syscall to connect
the two different prototypes. Both =sysdig= and =strace= did not know this, and
were interpreting the syscall inputs incorrectly.

There's even an [[https://lwn.net/Articles/311630/][LWN article]] about the discussion that took place when this was
originally implemented. There are various compatibility issues, and this was the
best method, apparently.

** DONE More Cscope benchmarks                               :tools:dev:data:
   CLOSED: [2014-04-20 Sun 23:43]

A patch to [[http://cscope.sourceforge.net][cscope]] was just posted: https://sourceforge.net/p/cscope/patches/86/.
This claims to speed up the building of the inverted index by using a more
efficient search algorithm in one place, and a better sorting implementation in
another. Since I did some cscope benchmarks earler ([[file:{lisp}(ob:link-to-post (ob:get-post-by-title "Cscope benchmarks")){/lisp}][here]] and [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "GNU Global benchmarks")){/lisp}][here]]), I can easily
evaluate this patch, so I did this.

*** Test description

The results aren't directly comparable to the timings in the previous posts,
since the project being indexed (Linux kernel) is at a very different version;
much more recent and with many more sources. The test machine is the same as
before. All the tests were done with a real ext3 hard disk, /not/ a ramdisk. The
cscope is the stock cscope 15.8a-2 from Debian.

*** Results

All timings are in seconds.

**** Cold disk cache

|                                              |   Stock | Patched |
|----------------------------------------------+---------+---------|
| Initial database build                       | 123.572 | 95.5225 |
| Database re-build after touching a file      | 57.2912 |   30.91 |
| Initial search                               | 9.11125 |   8.415 |
| Re-search after touching a file              | 59.6287 |   31.92 |
| Initial no-db-update search                  | 0.80625 |  1.2075 |
| No-db-update re-search after touching a file |   0.805 |    0.95 |

**** Warm disk cache

|                                              |   Stock | Patched |
|----------------------------------------------+---------+---------|
| Initial database build                       | 55.3537 | 29.5287 |
| Database re-build after touching a file      | 45.4975 |  18.805 |
| Initial search                               | 0.12125 |    0.12 |
| Re-search after touching a file              |  45.985 | 19.0437 |
| Initial no-db-update search                  |       0 |       0 |
| No-db-update re-search after touching a file |       0 | 0.00125 |

Note that this tests /only the timings/. I did not actually look at the results
being produced. Presumably they match, but I did not check.

*** Conclusions

Yeah. Much faster. Hopefully this produces the correct results, and gets merged
in some form.

*** Benchmark script

Here's the script that was used to get the timings. It's pretty much the same as
before, with small modifications to set what is being tested. As before, this is
a =zsh= script. It uses some =zsh=-isms, but could be converted to =bash= if
somebody cares to do it.

#+begin_src sh
#!/bin/zsh

# needed in cleandb()
setopt nonomatch

function dropcaches() {
    if [[ $warmcold == "cold" ]]; then
        sync ;
        sudo sysctl -w vm.drop_caches=3;
    fi
    sleep 2;
}

function cleandb() {
    # requires nonomatch option to ignore missing globs
    rm -f cscope.out* G*;
}

function touchfile() {
    sleep 2; # very important. cscope needs this to see the file update
    touch include/drm/drm_edid.h;
}

TIMEFMT='%E'

awktally='
BEGIN {
  skip = ENVIRON["skip"]
}

/^[0-9\.]+s$/ {
  gsub("s","");
  str = str " " $1
  if( n >= skip )
  {
    sum += $1;
  }
  n++;
}

END {
  print ENVIRON["name"] ": skipping: " skip " all: " str " mean: " sum/(n-skip)
}'

typeset -A skipcounts
skipcounts=(cold 2 warm 2)

modeoptions="-k -q"

cscope-indexer -l -r

Nrepeat=8

for mode (kernel patched)
{
    if [[ $mode == "patched" ]]; then
        cmd="/tmp/cscope-15.8a-patched/src/cscope $modeoptions";
    else
        cmd="/tmp/cscope-15.8a/src/cscope $modeoptions";
    fi

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial build; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                else
                    cleandb;
                fi
                dropcaches;
                time ${(z)cmd} -b;
            } |& awk $awktally
        }
    }

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial search; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                fi
                dropcaches;
                time ${(z)cmd} -L0 main > /dev/null;
            } |& awk $awktally
        }
    }

    for dotouch (0 1)
    {
        for warmcold (cold warm)
        {
            export name="$warmcold initial no-db search; $mode mode; touching: $dotouch";
            export skip=$skipcounts[$warmcold];
            repeat $(($Nrepeat + $skip)) {
                if (($dotouch)); then
                    touchfile;
                fi
                dropcaches;
                time ${(z)cmd} -d -L0 main > /dev/null;
            } |& awk $awktally
        }
    }
}
#+end_src

*** original benchmark data                                        :noexport:
cold initial build; kernel mode; touching: 0: skipping: 2 all:  126.28 126.63 124.29 125.34 122.14 121.44 124.63 122.28 122.81 125.65 mean: 123.572
warm initial build; kernel mode; touching: 0: skipping: 2 all:  89.94 62.50 56.71 55.47 55.03 54.61 55.70 55.26 54.72 55.33 mean: 55.3537
cold initial build; kernel mode; touching: 1: skipping: 2 all:  56.69 59.06 57.32 57.04 57.00 57.08 57.56 57.46 57.27 57.60 mean: 57.2912
warm initial build; kernel mode; touching: 1: skipping: 2 all:  52.52 44.44 45.47 44.71 45.16 44.60 46.76 44.70 45.61 46.97 mean: 45.4975
cold initial search; kernel mode; touching: 0: skipping: 2 all:  8.33 8.27 8.30 11.44 9.70 8.50 8.28 8.38 9.96 8.33 mean: 9.11125
warm initial search; kernel mode; touching: 0: skipping: 2 all:  0.13 0.13 0.12 0.12 0.12 0.13 0.12 0.12 0.12 0.12 mean: 0.12125
cold initial search; kernel mode; touching: 1: skipping: 2 all:  60.87 61.72 62.23 59.06 59.06 60.08 58.66 58.50 57.91 61.53 mean: 59.6287
warm initial search; kernel mode; touching: 1: skipping: 2 all:  50.66 48.51 47.33 46.55 45.50 45.18 44.43 46.96 47.43 44.50 mean: 45.985
cold initial no-db search; kernel mode; touching: 0: skipping: 2 all:  0.98 0.65 0.96 0.65 0.97 0.65 0.97 0.64 0.96 0.65 mean: 0.80625
warm initial no-db search; kernel mode; touching: 0: skipping: 2 all:  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 mean: 0
cold initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.97 0.64 0.96 0.64 0.97 0.65 0.95 0.65 0.97 0.65 mean: 0.805
warm initial no-db search; kernel mode; touching: 1: skipping: 2 all:  0.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 mean: 0
cold initial build; patched mode; touching: 0: skipping: 2 all:  95.11 97.38 95.83 97.90 95.01 95.20 93.65 94.51 95.92 96.16 mean: 95.5225
warm initial build; patched mode; touching: 0: skipping: 2 all:  30.03 29.29 29.68 29.13 29.57 29.33 29.92 29.01 29.34 30.25 mean: 29.5287
cold initial build; patched mode; touching: 1: skipping: 2 all:  31.32 30.97 30.92 30.80 30.78 31.09 32.26 30.75 29.89 30.79 mean: 30.91
warm initial build; patched mode; touching: 1: skipping: 2 all:  18.05 18.20 18.46 18.94 18.68 18.43 18.92 19.12 18.86 19.03 mean: 18.805
cold initial search; patched mode; touching: 0: skipping: 2 all:  9.68 8.12 8.12 8.11 9.28 8.17 8.15 7.95 8.19 9.35 mean: 8.415
warm initial search; patched mode; touching: 0: skipping: 2 all:  0.13 0.13 0.12 0.12 0.12 0.12 0.12 0.12 0.12 0.12 mean: 0.12
cold initial search; patched mode; touching: 1: skipping: 2 all:  28.92 29.93 31.87 33.01 31.26 34.48 31.39 30.79 31.38 31.18 mean: 31.92
warm initial search; patched mode; touching: 1: skipping: 2 all:  18.63 18.58 18.62 19.00 18.61 18.51 19.34 18.36 19.06 20.85 mean: 19.0437
cold initial no-db search; patched mode; touching: 0: skipping: 2 all:  1.11 0.67 1.09 0.66 1.06 0.67 3.29 0.68 1.54 0.67 mean: 1.2075
warm initial no-db search; patched mode; touching: 0: skipping: 2 all:  0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 mean: 0
cold initial no-db search; patched mode; touching: 1: skipping: 2 all:  1.04 0.66 1.02 0.65 1.02 0.77 1.28 0.81 1.22 0.83 mean: 0.95
warm initial no-db search; patched mode; touching: 1: skipping: 2 all:  0.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 mean: 0.00125

** DONE Even better notifications                             :tools:desktop:
   CLOSED: [2014-05-01 Thu 14:39]

Two previous posts ([[file:{lisp}(ob:link-to-post (ob:get-post-by-title "X11 urgency hint and notifications")){/lisp}][X11 urgency hint and notifications]] and [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "Already-running process notifications")){/lisp}][Already-running
process notifications]]) talked about ways to notify the user about terminating
shell processes. I've been living with this setup for a little while, and I just
thought of a better way to do this. Instead of the user asking for notifications
about particular processes, why not get notifications about /all/ processes?

As before, I'm using the X11 urgency hint. This hint is automatically removed by
the window manager when the hinted window is focused. Thus if you set an urgency
hint on an already-focused window, nothing will happen. Thus setting urgency on
completion of every single command won't generate too much noise, since most of
the time we're in the same terminal window at the start /and/ the stop of the
command. You /will/ see a notification when you move to a different window
before the process exits, which is /exactly/ what you want here.

=zsh= has a convenient hook that can be used for this: =precmd= is called right
before the shell prompt is printed. So to notify on all completions, you can put
into your =.zshrc=:

#+begin_src sh
function precmd {
  seturgent
}
#+end_src

This works, with one caveat: as described previously, =seturgent= is a perl
script, and calling it this way one can feel the overhead. It feels slower than
it should be. Since =seturgent= isn't doing any searching here, I rewrote the
chunk of it we're using in C. As one would think, it's way quicker:

=seturgent_fast.c=
#+begin_src C
#include <stdio.h>
#include <stdlib.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

int main(void)
{
    const char* window_idstring = getenv("WINDOWID");
    if( window_idstring == NULL )
    {
        fprintf(stderr, "No WINDOWID set\n");
        return 1;
    }
    Window w = atoi(window_idstring);
    if( w <= 0 )
    {
        fprintf(stderr, "Couldn't parse window id '%s'\n",
                window_idstring);
        return 1;
    }


    Display* display;
    const char* displaystring = getenv("DISPLAY");
    if( displaystring == NULL )
    {
        fprintf(stderr, "No DISPLAY set\n");
        return 1;
    }

    display = XOpenDisplay(displaystring);
    if( display == NULL )
    {
        fprintf(stderr, "Couldn't open display '%s\n", displaystring);
        return 1;
    }

    XWMHints* hints = XGetWMHints(display, w);
    if( hints == NULL )
    {
        fprintf(stderr, "Couldn't retrieve hints\n");
        return 1;
    }

    hints->flags |= XUrgencyHint;
    XSetWMHints(display, w, hints);

    XFree(hints);
    XFlush(display);
    XCloseDisplay(display);
    return 0;
}
#+end_src

This can be built simply with

#+begin_src sh
gcc -lX11 -o seturgent_fast{,.c}
#+end_src

Running this for a bit the main discovery is that it's a bit easier to maintain
focus. Previously, I'd start a build or APT update (or whatever), then go do
something else, checking on the progress of the long task periodically. This
punctuated workflow is fairly inefficient, and the notification system help to
minimize it as much as is possible.

So yeah. I'll run this for a bit more, and we'll see if there's more to improve.
   
** DONE Emacs-snapshot package hosting                                :emacs:
   CLOSED: [2014-06-07 Sat 17:29]

A few months ago, Julian Danjou stopped updating his bleeding-edge GNU Emacs
Debian packages (http://emacs.naquadah.org/). I've been using those for a while,
and I'd like to continue doing so. Thus, I'm now building and hosting my own
bleeding-edge packages: http://emacs.secretsauce.net/.

There's nothing particularly noteworthy about the building or hosting of these.
The =/etc/apt/sources.list= entries are

#+BEGIN_EXAMPLE
deb     [arch=amd64] http://emacs.secretsauce.net unstable main
deb-src [arch=amd64] http://emacs.secretsauce.net unstable main
#+END_EXAMPLE

In other news, it turns out that web site hosting is now incredibly cheap.

** DONE Tab completion for sysdig                                     :tools:
   CLOSED: [2014-06-23 Mon 18:10]

I just implemented =zsh= tab-completion functionality for =sysdig=:

 https://raw.githubusercontent.com/dkogan/sysdig/master/scripts/completions/zsh/_sysdig

The patch was merged to =sysdig= upstream.

It's fairly nice, and makes =sysdig= easier to use for those who don't yet have
all the knobs memorized, such as myself. I complete on

- commandline options
- commandline option arguments
- chisel names
- chisel arguments
- filter field names

Some of those are hard-coded in the completion script, and some are reported by
the =sysdig= executable itself. Having written this I'm now acutely aware of
missing similar functionality in =tcpdump= and =perf=. Both of those have some
tab completion, but do not complete on event types. If they did, writing things
like =tcpdump= filters would be much easier. That's a good thing to add at some
point.

Another interesting discovery is that it is apparently normal for =zsh=
completion scripts to live in the =zsh= repository, /not/ in the repository of
the thing being completed. So in this case I apparently went against to grain by
contributing my script to =sysdig= instead of =zsh=. This feels right, though.
But if I make those additions to =tcpdump= and/or =perf= completions, those will
go to the =zsh= people.

** DONE Ltrace filtering details                                      :tools:
   CLOSED: [2014-06-25 Wed 16:51]
   
In an [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "Reading DWARF prototypes in ltrace")){/lisp}][earlier post]] I talked about teaching ltrace to read function prototypes
from DWARF data. I'm making more progress on that front, and the initial code
has been merged into the upstream ltrace repository. One point of confusion for
me was the difference between ltrace's various filtering commandline options
=-x=, =-e=, =-l= and =-L=. I added a more thorough description and an example to
the ltrace manpage, and I'm discussing this here.

The ltrace filters specify which functions should be instrumented. Since ltrace
introduces non-negligible overhead to the running process, it's very desirable
to instrument only the functions you care about. Otherwise the process can be
slowed significantly.

Broadly speaking

- =-x= is *show me what calls these symbols (including local calls)*
- =-e= is *show me what calls these symbols (inter-library calls only)*
- =-l= is *show me what calls into this library*

Inter-library and intra-library calls are treated separately because they are
implemented differently in the binary. Calls into a shared object use the PLT
mechanism, while local calls do not.

If no =-e= or =-l= filtering options are given, ltrace assumes a default filter
of =-e @MAIN= (trace all non-local calls into the main executable). If only a
=-x= is given, this default filter is /still/ present, and it can be turned off
by passing =-L=. In my experience, if you're using =-x=, you pretty much always
want =-L= as well.

*** Example

Suppose I have a library defined with this header =tstlib.h=:

#+BEGIN_SRC C
#pragma once
void func_f_lib(void);
void func_g_lib(void);
#+END_SRC

and this implementation =tstlib.c=:

#+BEGIN_SRC C
#include "tstlib.h"
void func_f_lib(void)
{
    func_g_lib();
}
void func_g_lib(void)
{
}
#+END_SRC

Note that =func_f_lib()= and =func_g_lib()= are both external symbols. I have an
executable that uses this library defined like this =tst.c=:

#+BEGIN_SRC C
#include "tstlib.h"
void func_f_main(void)
{
}
void main(void)
{
    func_f_main();
    func_f_lib();
}
#+END_SRC

Note that =func_f_main()= is an external symbol as well.

If linking with =-Bdynamic= (the default for pretty much everybody), the
internal =func_g_lib()= and =func_g_main()= calls use the PLT like external
calls, and thus ltrace says:

#+BEGIN_EXAMPLE
$ gcc -Wl,-Bdynamic -shared -fPIC -g -o tstlib.so tstlib.c

$ gcc -Wl,-rpath=$PWD -g -o tst tst.c tstlib.so

$ ltrace -x 'func*' -L ./tst

func_f_main()                             = <void>
func_f_lib@tstlib.so( <unfinished ...>
func_g_lib@tstlib.so()                    = <void>
<... func_f_lib resumed> )                = <void>
+++ exited (status 163) +++


$ ltrace -e 'func*' ./tst

tst->func_f_lib( <unfinished ...>
tstlib.so->func_g_lib()                   = <void>
<... func_f_lib resumed> )                = <void>
+++ exited (status 163) +++


$ ltrace -l tstlib.so ./tst

tst->func_f_lib( <unfinished ...>
tstlib.so->func_g_lib()                   = <void>
<... func_f_lib resumed> )                = <void>
+++ exited (status 163) +++
#+END_EXAMPLE

By contrast, if linking the shared library with =-Bsymbolic=, then the internal
=func_g_lib()= call bypasses the PLT, and ltrace says:

#+BEGIN_EXAMPLE
$ gcc -Wl,-Bsymbolic -shared -fPIC -g -o tstlib.so tstlib.c

$ gcc -Wl,-rpath=$PWD -g -o tst tst.c tstlib.so

$ ltrace -x 'func*' -L ./tst

func_f_main() = <void>
func_f_lib@tstlib.so( <unfinished ...>
func_g_lib@tstlib.so()                    = <void>
<... func_f_lib resumed> )                = <void>
+++ exited (status 163) +++


$ ltrace -e 'func*' ./tst

tst->func_f_lib()                         = <void>
+++ exited (status 163) +++


$ ltrace -l tstlib.so ./tst

tst->func_f_lib()                         = <void>
+++ exited (status 163) +++
#+END_EXAMPLE

Note that the =-x= traces are the same in both cases, since =-x= traces local
/and/ external calls. However =-e= and =-l= trace only external calls, so with
=-Bsymbolic=, local calls to =func_g_lib()= do not appear there.

** DONE Reading DWARF prototypes in ltrace (part 2)               :tools:dev:
   CLOSED: [2014-07-10 Thu 01:20]

As mentioned [[file:{lisp}(ob:link-to-post (ob:get-post-by-title "Reading DWARF prototypes in ltrace")){/lisp}][earlier]], I'm adding functionality to ltrace to read function
prototypes from DWARF debugging information. The bulk of this work was merged
upstream. I'm now hunting corner cases and various details in this whole system
before moving on to implement more features. Unsurprisingly, trying to trace
calls in libc is a rich source of corner cases. Some of these are discussed here
in no particular order.

*** Missing features
    
Ltrace currently chokes (crashes!) when encountering prototypes with particular
features. Some of these are

- Complex numbers
- =void= variables
- =union= fields
- bit fields

Most of the time these aren't used, but glibc has them somewhere, and ltrace can
get confused when the new DWARF-reading code parses glibc.


*** C++ symbol names

Some DWARF symbol DIEs have a =DW_AT_linkage_name= tag in addition to the normal
=DW_AT_name= tag. The purpose of this wasn't entirely obvious until I tried to
ltrace a C++ program. Suppose I have this trivial C++ program:

=tst.cc=
#+BEGIN_SRC C
class C
{
    void f(void);
};

void C::f(void)
{
}
#+END_SRC

I compile it, and dump the debug info:

#+begin_example

$ g++ -g -o tst.o -c tst.cc && readelf -w tst.o
....
 <2><37>: Abbrev Number: 3 (DW_TAG_subprogram)
    <38>   DW_AT_external    : 1
    <38>   DW_AT_name        : f
    <3a>   DW_AT_decl_file   : 1
    <3b>   DW_AT_decl_line   : 3
    <3c>   DW_AT_linkage_name: (indirect string, offset: 0x4e): _ZN1C1fEv
    <40>   DW_AT_declaration : 1
    <40>   DW_AT_object_pointer: <0x44>
....
#+end_example

Note that for my method =f= the =DW_AT_name= is =f=, but the
=DW_AT_linkage_name= is =_ZN1C1fEv=. The linker does not know C++, and it only
seems symbol names. Here this symbol name is the mangled =_ZN1C1fEv=, so as far
as ltrace is concerned, this is the name of this function and thus it should use
=DW_AT_linkage_name= here. One could think that the parsing rule in ltrace
should be "use =DW_AT_linkage_name= if it exists, otherwise use
=DW_AT_linkage_name=". One would be wrong, since the next section shows that
this logic is too simple.

*** Aliased symbols (different symbol, same address)

Trying to ltrace this simple program doesn't work when reading the DWARF
prototypes automatically:

=tst.c=
#+begin_src C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
int main(void)
{
    nanosleep( &(struct timespec){.tv_sec=0,.tv_nsec=33}, NULL);
    usleep(44);
    return 0;
}
#+end_src

I get this:

#+begin_example
$ gcc -o tst tst.c
$ ltrace -l 'libc.so*' -L ./tst
tst->__libc_start_main(0x40054d, 1, 0x7fffc04253f8, 0x400590 <unfinished ...>
tst->nanosleep(0x7fffc0425300, 0, 0x7fffc0425408, 0)                 = 0
tst->usleep(44)                                                      = <void>
+++ exited (status 0) +++
#+end_example

Note that the =nanosleep()= call does not have the correct prototype. This is
because we call =nanosleep()=, but the DWARF defines =__nanosleep= and
=__GI___nanosleep=:

#+begin_example
$ nm -D tst | grep nanosleep

                 U nanosleep


$ nm -D /lib/x86_64-linux-gnu/libc-2.18.so | grep nanosleep

00000000000f26f0 T __clock_nanosleep
00000000000b7070 W __nanosleep
00000000000f26f0 W clock_nanosleep
00000000000b7070 W nanosleep


$ readelf -w /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.18.so | grep nanosleep

    <20c7cf>   DW_AT_name        : (indirect string, offset: 0x13a95): __nanosleep
    <20c7d5>   DW_AT_linkage_name: (indirect string, offset: 0x13a90): __GI___nanosleep
    <280d67>   DW_AT_name        : (indirect string, offset: 0x13a95): __nanosleep
    <280d6d>   DW_AT_linkage_name: (indirect string, offset: 0x13a90): __GI___nanosleep
    <2dc871>   DW_AT_name        : (indirect string, offset: 0x1d940): __clock_nanosleep
    <3b0b59>   DW_AT_name        : (indirect string, offset: 0x13a95): __nanosleep
    <3b0b5f>   DW_AT_linkage_name: (indirect string, offset: 0x13a90): __GI___nanosleep
#+end_example

We can resolve this discrepancy by noting that the =nanosleep= symbol in the
libc symbol table has the same address as =__nanosleep=, and use =__nanosleep='s
DWARF prototype. I implemented this, and the patch is currently in review.

*** Aliased addresses (same symbol, different address)

Testing further, I discovered that in the libc on my machine (Debian/sid amd64)
some symbols appear at multiple addresses:

#+begin_example
$ nm -D /lib/x86_64-linux-gnu/libc-2.18.so | awk '{print $NF}' | sort | uniq -d
_sys_errlist
_sys_nerr
_sys_siglist
memcpy
nftw
nftw64
posix_spawn
posix_spawnp
pthread_cond_broadcast
pthread_cond_destroy
pthread_cond_init
pthread_cond_signal
pthread_cond_timedwait
pthread_cond_wait
realpath
regexec
sched_getaffinity
sched_setaffinity
sys_errlist
sys_nerr
sys_sigabbrev
sys_siglist
#+end_example

This can make the DWARF parser confused. Looking into it, it looks like those
are versioned symbols, with different implementation for different libc
versions. This same-symbol-different-address idea doesn't fit into the data
structures, as I've currently defined them. Currently I simply take the first
such symbol I encounter and ignore the rest. I probalby should parse this out
fully, but it hardly seems worth the effort.

** DONE Closures and cookies in C                                       :dev:
   CLOSED: [2014-07-17 Thu 17:43]

I recently discovered something that's /very/ old news to functional programming
people, but was new to me, especially as being applied to C. It is common
practice in C coding to use callback functions when a general routine needs to
do something specific that the caller knows about. Furthermore, a =void* cookie=
is generally used to pass context to this callback.

Here's a simple C99 example of a linked-list structure and a iterator that calls
a callback function for each element of the list. The iterator takes a =cookie=
argument, which it passes on untouched to the callback. This =cookie= means
something to the caller of the iterator and to the callback, but it means
nothing to the iterator itself. This is the usual idiom. Furthermore, the
example contains a simple use of this iterator, to print all node values to a
particular =FILE=:

#+begin_src c
#include <stdio.h>

struct node
{
    int x;
    struct node* next;
};

typedef void (*foreach_callback)(const struct node* node, void* cookie);

static void foreach(const struct node* list,
                    const foreach_callback cb, void* cookie)
{
    while(list != NULL)
    {
        cb(list, cookie);
        list = list->next;
    }
}




static void print_node(const struct node* node, FILE* fp)
{
    fprintf(fp, "%d\n", node->x);
}

static void print_nodes(const struct node* list, FILE* fp)
{
    foreach(list, (foreach_callback)print_node, fp);
}

int main(void)
{
    struct node list =
        {.x = 10,
         .next = &(struct node){.x = 11,
                                .next = &(struct node){.x = 12,
                                                       .next = NULL}}};

    print_nodes(&list, stdout);
    return 0;
}
#+end_src

This works fine, and things have been done this way for a very long time. As
written, =print_node()= is visible to most of the source file, even though it is
only used by =print_nodes()=. It would be nice if =print_node()= was visible
/only/ from that one function that uses it. This is not possible in standard C.
However GCC has a [[https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html][non-standard extension]] that allows such things: nested
functions. With that in mind, we can rewrite the example like so:

#+begin_src c
#include <stdio.h>

struct node
{
    int x;
    struct node* next;
};

typedef void (*foreach_callback)(const struct node* node, void* cookie);

static void foreach(const struct node* list,
                    const foreach_callback cb, void* cookie)
{
    while(list != NULL)
    {
        cb(list, cookie);
        list = list->next;
    }
}




static void print_nodes(const struct node* list, FILE* fp)
{
    void print_node(const struct node* node, FILE* fp)
    {
        fprintf(fp, "%d\n", node->x);
    }


    foreach(list, (foreach_callback)print_node, fp);
}

int main(void)
{
    struct node list =
        {.x = 10,
         .next = &(struct node){.x = 11,
                                .next = &(struct node){.x = 12,
                                                       .next = NULL}}};

    print_nodes(&list, stdout);
    return 0;
}
#+end_src

That's nicer. =print_nodes()= is now self-contained, and none of its
implementation details leak out. At this point we're not using the nested
function as anything more than just syntactic sugar. However, these aren't
simply /nested functions/; they're full /closures/, i.e. the nested function has
access to the local variables of its surrounding scope. This means that
=print_node()= can see the =fp= argument to =print_nodes()=, and doesn't need to
be passed it. Thus *we do not need the cookie!* The state maintained by the
nested function takes on the work that the cookie did for us previously. As
such, we can rewrite this example with no cookies at all:


#+begin_src c
#include <stdio.h>

struct node
{
    int x;
    struct node* next;
};

typedef void (*foreach_callback)(const struct node* node);

static void foreach(const struct node* list, const foreach_callback cb)
{
    while(list != NULL)
    {
        cb(list);
        list = list->next;
    }
}




static void print_nodes(const struct node* list, FILE* fp)
{
    void print_node(const struct node* node)
    {
        fprintf(fp, "%d\n", node->x);
    }


    foreach(list, print_node);
}

int main(void)
{
    struct node list =
        {.x = 10,
         .next = &(struct node){.x = 11,
                                .next = &(struct node){.x = 12,
                                                       .next = NULL}}};

    print_nodes(&list, stdout);
    return 0;
}
#+end_src


Neat! Clearly this is non-portable. It also is potentially unsafe since
internally the compiler generates a bit of code on the stack and runs it. Still,
the code looks nicer and we don't need cookies.


* init                                                             :noexport:
Local Variables:
eval: (progn
          (auto-fill-mode)
          (load-library "compile")
          (load-library "o-blog")
          (setq org-html-table-default-attributes
            '(:border "2" :cellspacing "0" :cellpadding "6" :rules "all" :frame "box"))
          (local-set-key (kbd "<f5>")
                         (lambda () (interactive)
                           (org-publish-blog (buffer-file-name))
                           (browse-url "http://127.0.0.1/blog/")))
          (local-set-key (kbd "<S-f5>")
                         (lambda () (interactive)
                           (shell-command "cd out; git clean -ffdx")
                           (org-publish-blog (buffer-file-name))
                           (shell-command "git push; cd out; git add -A && git commit -a -m 'update' && git push;")))
          (defun ob:link-to-post (post)
            (format "%s/%s" (ob:path-to-root) (ob:post-htmlfile post)))
          (defun ob:get-post-by-title (title)
            (let ((posts (ob:get-posts
                          (lambda (x)
                            (equal title (ob:post-title x)))
                          1)))
              (if posts (car posts) nil))))
End:
